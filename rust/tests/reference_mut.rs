/*
    引用的使用
        可变变量： 能被修改的变量，定义为可变变量
        不可变引用： 可变变量有不可变引用，不可变引用无法解引修改可变变量
        可变引用： 可变引用可以修改可变变量
*/
fn add_ref(i: &mut i32) {
    *i += 1;
}

#[test]
fn test_deref() {
    //定义一个可变变量
    let mut s = 5;
    let s2 = 3;

    //mut变量可以有不可变引用
    let _r1 = &s;
    // *r1 += 1;
    // ^这句错误，不可变引用无法修改可变变量

    //可变引用可以修改可变变量，需要通过解引用修改
    let r2 = &mut s;
    *r2 += 1;
    println!("r2:{}", r2);

    //通过函数传递方式使用可变引用
    let r3 = &mut s;
    add_ref(r3);
    println!("r3:{}", r3);
}

//可变引用具有排他性。当可变应用存在时，不能有其他不可变引用或可变引用
//不可变引用没有拍他性
#[test]
fn test_exclusive() {
    //定义一个可变变量
    let mut s = 5;

    //可以存在多个不可变引用
    let r1 = &s;
    let r2 = &s;
    println!("{} and {}", r1, r2);

    //只能存在一个可变引用
    let r3 = &mut s;
    //println!("{}, {}, and {}", r1, r2, r3);
    //^ 上面这句错误，不能r1，r2和r3同时使用。
    //如果上一句注释掉后， r1,r2作用域在这里结束，可以使用r3

    //现在r3独自拥有可变引用
    println!("{}", r3);
}
